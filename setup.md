sudo apt update && sudo apt upgrade -y
sudo apt install -y build-essential curl wget git ca-certificates gnupg lsb-release
mkdir -p ~/.local/env
mkdir -p ~/.local/bin
mkdir -p ~/bin
mkdir -p ~/scripts/{system,backup,dev,utils}
mkdir -p ~/Work
mkdir -p ~/Backups
mkdir -p ~/notes
create eenv.sh file
install zsh
sh -c #!/bin/sh # # This script should be run via curl: # sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" # or via wget: # sh -c "$(wget -qO- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" # or via fetch: # sh -c "$(fetch -o - https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" # # As an alternative, you can first download the install script and run it afterwards: # wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh # sh install.sh # # You can tweak the install behavior by setting variables when running the script. For # example, to change the path to the Oh My Zsh repository: # ZSH=~/.zsh sh install.sh # # Respects the following environment variables: # ZDOTDIR - path to Zsh dotfiles directory (default: unset). See [1][2] # [1] https://zsh.sourceforge.io/Doc/Release/Parameters.html#index-ZDOTDIR # [2] https://zsh.sourceforge.io/Doc/Release/Files.html#index-ZDOTDIR_002c-use-of # ZSH - path to the Oh My Zsh repository folder (default: $HOME/.oh-my-zsh) # REPO - name of the GitHub repo to install from (default: ohmyzsh/ohmyzsh) # REMOTE - full remote URL of the git repo to install (default: GitHub via HTTPS) # BRANCH - branch to check out immediately after install (default: master) # # Other options: # CHSH - 'no' means the installer will not change the default shell (default: yes) # RUNZSH - 'no' means the installer will not run zsh after the install (default: yes) # KEEP_ZSHRC - 'yes' means the installer will not replace an existing .zshrc (default: no) # # You can also pass some arguments to the install script to set some these options: # --skip-chsh: has the same behavior as setting CHSH to 'no' # --unattended: sets both CHSH and RUNZSH to 'no' # --keep-zshrc: sets KEEP_ZSHRC to 'yes' # For example: # sh install.sh --unattended # or: # sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended # set -e # Make sure important variables exist if not already defined # # $USER is defined by login(1) which is not always executed (e.g. containers) # POSIX: https://pubs.opengroup.org/onlinepubs/009695299/utilities/id.html USER=${USER:-$(id -u -n)} # $HOME is defined at the time of login, but it could be unset. If it is unset, # a tilde by itself (~) will not be expanded to the current user's home directory. # POSIX: https://pubs.opengroup.org/onlinepubs/009696899/basedefs/xbd_chap08.html#tag_08_03 HOME="${HOME:-$(getent passwd $USER 2>/dev/null | cut -d: -f6)}" # macOS does not have getent, but this works even if $HOME is unset HOME="${HOME:-$(eval echo ~$USER)}" # Track if $ZSH was provided custom_zsh=${ZSH:+yes} # Use $zdot to keep track of where the directory is for zsh dotfiles # To check if $ZDOTDIR was provided, explicitly check for $ZDOTDIR zdot="${ZDOTDIR:-$HOME}" # Default value for $ZSH # a) if $ZDOTDIR is supplied and not $HOME: $ZDOTDIR/ohmyzsh # b) otherwise, $HOME/.oh-my-zsh if [ -n "$ZDOTDIR" ] && [ "$ZDOTDIR" != "$HOME" ]; then ZSH="${ZSH:-$ZDOTDIR/ohmyzsh}" fi ZSH="${ZSH:-$HOME/.oh-my-zsh}" # Default settings REPO=${REPO:-ohmyzsh/ohmyzsh} REMOTE=${REMOTE:-https://github.com/${REPO}.git} BRANCH=${BRANCH:-master} # Other options CHSH=${CHSH:-yes} RUNZSH=${RUNZSH:-yes} KEEP_ZSHRC=${KEEP_ZSHRC:-no} command_exists() { command -v "$@" >/dev/null 2>&1 } user_can_sudo() { # Check if sudo is installed command_exists sudo || return 1 # Termux can't run sudo, so we can detect it and exit the function early. case "$PREFIX" in *com.termux*) return 1 ;; esac # The following command has 3 parts: # # 1. Run `sudo` with `-v`. Does the following: # ‚Ä¢ with privilege: asks for a password immediately. # ‚Ä¢ without privilege: exits with error code 1 and prints the message: # Sorry, user <username> may not run sudo on <hostname> # # 2. Pass `-n` to `sudo` to tell it to not ask for a password. If the # password is not required, the command will finish with exit code 0. # If one is required, sudo will exit with error code 1 and print the # message: # sudo: a password is required # # 3. Check for the words "may not run sudo" in the output to really tell # whether the user has privileges or not. For that we have to make sure # to run `sudo` in the default locale (with `LANG=`) so that the message # stays consistent regardless of the user's locale. # ! LANG= sudo -n -v 2>&1 | grep -q "may not run sudo" } # The [ -t 1 ] check only works when the function is not called from # a subshell (like in `$(...)` or `(...)`, so this hack redefines the # function at the top level to always return false when stdout is not # a tty. if [ -t 1 ]; then is_tty() { true } else is_tty() { false } fi # This function uses the logic from supports-hyperlinks[1][2], which is # made by Kat March√°n (@zkat) and licensed under the Apache License 2.0. # [1] https://github.com/zkat/supports-hyperlinks # [2] https://crates.io/crates/supports-hyperlinks # # Copyright (c) 2021 Kat March√°n # # Licensed under the Apache License, Version 2.0 (the "License"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an "AS IS" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. supports_hyperlinks() { # $FORCE_HYPERLINK must be set and be non-zero (this acts as a logic bypass) if [ -n "$FORCE_HYPERLINK" ]; then [ "$FORCE_HYPERLINK" != 0 ] return $? fi # If stdout is not a tty, it doesn't support hyperlinks is_tty || return 1 # DomTerm terminal emulator (domterm.org) if [ -n "$DOMTERM" ]; then return 0 fi # VTE-based terminals above v0.50 (Gnome Terminal, Guake, ROXTerm, etc) if [ -n "$VTE_VERSION" ]; then [ $VTE_VERSION -ge 5000 ] return $? fi # If $TERM_PROGRAM is set, these terminals support hyperlinks case "$TERM_PROGRAM" in Hyper|iTerm.app|terminology|WezTerm|vscode) return 0 ;; esac # These termcap entries support hyperlinks case "$TERM" in xterm-kitty|alacritty|alacritty-direct) return 0 ;; esac # xfce4-terminal supports hyperlinks if [ "$COLORTERM" = "xfce4-terminal" ]; then return 0 fi # Windows Terminal also supports hyperlinks if [ -n "$WT_SESSION" ]; then return 0 fi # Konsole supports hyperlinks, but it's an opt-in setting that can't be detected # https://github.com/ohmyzsh/ohmyzsh/issues/10964 # if [ -n "$KONSOLE_VERSION" ]; then # return 0 # fi return 1 } # Adapted from code and information by Anton Kochkov (@XVilka) # Source: https://gist.github.com/XVilka/8346728 supports_truecolor() { case "$COLORTERM" in truecolor|24bit) return 0 ;; esac case "$TERM" in iterm |\ tmux-truecolor |\ linux-truecolor |\ xterm-truecolor |\ screen-truecolor) return 0 ;; esac return 1 } fmt_link() { # $1: text, $2: url, $3: fallback mode if supports_hyperlinks; then printf ']8;;%s\%s]8;;\
git clone https://github.com/zsh-users/zsh-autosuggestions /home/hunterkael/.oh-my-zsh/custom/plugins/zsh-autosuggestions
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git /home/hunterkael/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting
git clone https://github.com/zsh-users/zsh-history-substring-search /home/hunterkael/.oh-my-zsh/custom/plugins/zsh-history-substring-search

curl -sS https://starship.rs/install.sh | sh
install monoki nerd font and set in .fonts folder
sudo tar -xf mononoki-font.tar.gz -C /usr/share/fonts/
